#!/bin/bash

# This file is part of Devops Trouble Map (short DOTM).
#
# DOTM is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOTM is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with DOTM.  If not, see <http://www.gnu.org/licenses/>.

# This is a temporary hack to provide the "period state fetcher2
# functionality. As Bash is not the best choice for data transformations
# it should be reimplemented in Python using a real Redis binding

readonly PIDFILE=/tmp/$(basename $0).pid
readonly NETCAT="nc -w 3 "
readonly REDIS_CLI="redis-cli -n 0 -h localhost -p 6379"

# egrep expressions, filtering common ports
readonly LISTEN_FILTER="53|22|5666|4949|4848|25|631"		
readonly ESTABLISHED_FILTER="${LISTEN_FILTER}"

# Push a list of key values into a given Redis key
#
# $1		the key
# $2...$n	key value pairs
redis_push() {
	local key=$(shift)
	local output=$($REDIS_CLI hmset $key $@)
	if [ $? -ne 0 -o "$output" != "OK" ]; then 
		echo "ERROR: Failed to run '$REDIS_CLI hmset $key $@'!"
		echo "$output"
	fi
}

# Load configured whitelisted networks
declare -a netmasks
load_nets() {
	# Note: configuration contains CIDR netmasks that we need
	# to convert to hex values for easy checking 
	tmp="10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"
	for cidr in $tmp
	do
		if [[ $cidr =~ ([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/([0-9]+) ]]; then
			netmasks+=($(printf 'network=%02x%02x%02x%02x netmask=%08x\n' ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} ${BASH_REMATCH[4]} $((2**32-2**(32-${BASH_REMATCH[5]})))))
		else
			echo "ERROR: Invalid network address '$cidr'!"
		fi
	done
}

# Match all whitelisted netmask against a given IP
#
# $1	IPv4 address
#
# Returns 1 if any netmask matches, 0 otherwise
match_nets() {
	local ip=$1

	if [[ $ip =~ ([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
		ip=$(printf '%02x%02x%02x%02x' ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} ${BASH_REMATCH[4]})
	else
		echo "ERROR: Invalid IP '$ip'!"
		return 0
	fi

	for entry in ${!netmasks[*]}
	do	
		echo "checking $entry"
		eval "${netmasks[$entry]}"
		echo $ip - $network, $netmask
	done
}

PID=$(cat "$PIDFILE" 2>/dev/null)
if [ "$PID" != "" ]; then
	if kill -0 "$PID" >/dev/null; then
		echo "WARNING: Terminating, another instance is still running ($PID)!"
		exit 0
	fi
fi	
echo $$ >"$PIDFILE"

if ! $REDIS_CLI info >/dev/null; then
	echo "ERROR: Cannot run '$REDIS_CLI'! Is it installed?" >&2
	exit 1
fi

if ! $NETCAT -h 2>/dev/null; then
	echo "ERROR: Cannot run '$NETCAT'! Is it installed?" >&2
	exit 1
fi

readonly CLIENTS=$($REDIS_CLI lrange dotm::nodes 0 -1)
if [ "$CLIENTS" == "" ]; then
	echo "ERROR: Could not determine list of client nodes!" >&2
	exit 1
fi

declare -A listen_ports
declare -A used_services
for c in $CLIENTS;
do
	echo "Fetching from '$c'..."
	output=$($NETCAT "$c" 4848)
	if [ $? -ne 0 ]; then
		echo "ERROR: Fetching status from '$c' failed!" >&2
		continue
	fi

	# Validate output
	# - check for node name
	# - check for connection list
	# - check for IP list
	if [[ ! "$output" =~ ^hostname= ]]; then
		echo "ERROR: Result from '$c' missing hostname! Ignoring it." >&1
		continue
	fi

	# There should be at least one established connection (that's us!)
	if [[ ! "$output" =~ ESTABLISHED ]]; then
		echo "ERROR: Result from '$c' missing connection listing! Ignoring it." >&1
		continue
	fi
	
	# There should be at least one interface listed
	if [[ ! "$output" =~ inet\  ]]; then
		echo "ERROR: Result from '$c' missing interface listing! Ignoring it." >&1
		continue
	fi
	
	# Parse output and store into Redis
	now=$(date +%s)
	
	echo "Services:"
	unset listen_ports
	unset used_services
	while read proto recvq sendq localaddr remoteaddr state program rest; do
		localport=${localaddr##*:}
		program=${program##*/}
		program=${program:-unknown}
		echo "  -> listening on port $localport	(${program})"
		listen_ports[$localport]=${program}
		used_services[$localport]=0
	done < <(echo "$output" | grep "^tcp.*LISTEN" | egrep -v "$LISTEN_FILTER")

	echo "Connections:"
	while read proto recvq sendq localaddr remoteaddr state program rest; do
		localip=${localaddr%%:*}
		localport=${localaddr##*:}
		remoteip=${remoteaddr%%:*}
		remoteport=${remoteaddr##*:}
		program=${program##*/}
		program=${program:-unknown}

		if [ "${listen_ports[${localaddr##*:}]}" == "" ]; then
			# FIXME: Consolidate outgoing connections to 'Internet'
			# according to list of configured known networks
			echo "  -> outgoing connection to $remoteaddr (by $program)"
			conn_count=$(echo "$output" | grep "[[:space:]]$localip:[0-9][0-9]*[[:space:]]*$remoteaddr[[:space:]]" | wc -l)
			redis_push "dotm::connections::${remoteip}::${remoteport}::${c}" process "$program" last_seen "$now" connections "$conn_count" direction "out"	
		else
			# FIXME: Consolidate incoming connections based on frequency
			# e.g. count per net and combine to network if too many appear
			echo "  -> incoming from $remoteaddr (to $localport $program)"
			conn_count=$(echo "$output" | grep "[[:space:]]$localaddr[[:space:]]*$remoteip:[0-9][0-9]*[[:space:]]" | wc -l)
			redis_push "dotm::connections::${c}::${localport}::${remoteip}" process "$program" last_seen "$now" connections "$conn_count" direction "in"
			used_services[$localport]=1
		fi
	done < <(echo "$output" | grep ESTABL | egrep -v "$ESTABLISHED_FILTER")

	# Submit service list to indicate which ones are unused and which one are not
	for port in ${!used_services[*]};
	do
		program="${listen_ports[$port]}"
		program=${program:-unknown}
		if [[ ${used_services[$port]} -eq 0 ]]; then
			echo "  -> found unused service $port (${listen_ports[$port]})"
			redis_push "dotm::services::${c}::${port}" process "$program" last_seen "$now"
		else
			redis_push "dotm::services::${c}::${port}" process "$program" last_seen "$now" last_connection "$now"
		fi
	done

	# Crude "ip addr" parsing...
	ips=$(
	while read inet ip brd broadcast scope global interface rest; do
		echo ${ip%%/[0-9]*}
	done < <(echo "$output" | grep "inet " | grep -v "host lo") | xargs
	)
	echo "IPs:" ${ips// /,}
	for ip in $ips
	do
		$REDIS_CLI set dotm::resolver::ip_to_node::$ip $c >/dev/null
	done
	redis_push "dotm::nodes::${c} last_fetch '$now' fetch_status 'OK' ips '${ips// /,}'"
done

#load_nets
#match_nets 10.0.0.1
rm "$PIDFILE"
echo "Done."
