#!/bin/bash

# This file is part of Devops Trouble Map (short DOTM).
#
# DOTM is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOTM is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with DOTM.  If not, see <http://www.gnu.org/licenses/>.

# This is a temporary hack to provide the "period state fetcher2
# functionality. As Bash is not the best choice for data transformations
# it should be reimplemented in Python using a real Redis binding

readonly NETCAT="nc"
readonly REDIS_CLI="redis-cli -n 0 -h localhost -p 6379"

# egrep expressions, filtering common ports
readonly LISTEN_FILTER="53|22|5666|4949|4848|25|631"		
readonly ESTABLISHED_FILTER="${LISTEN_FILTER}"

# Push a list of key values into a given Redis key
#
# $1		the key
# $2...$n	key value pairs
redis_push() {
	local key=$(shift)
	local output=$($REDIS_CLI hmset $key $@)
	if [ $? -ne 0 -o "$output" != "OK" ]; then 
		echo "ERROR: Failed to run '$REDIS_CLI hmset $key $@'!"
		echo "$output"
	fi
}

if ! $REDIS_CLI info >/dev/null; then
	echo "ERROR: Cannot run '$REDIS_CLI'! Is it installed?" >&2
	exit 1
fi

if ! $NETCAT -h 2>/dev/null; then
	echo "ERROR: Cannot run '$NETCAT'! Is it installed?" >&2
	exit 1
fi

readonly CLIENTS=$($REDIS_CLI lrange dotm::nodes 0 -1)
if [ "$CLIENTS" == "" ]; then
	echo "ERROR: Could not determine list of client nodes!" >&2
	exit 1
fi

declare -A listen_ports
declare -A used_services
for c in $CLIENTS;
do
	echo "Fetching from '$c'..."
	output=$(nc "$c" 4848)
	if [ $? -ne 0 ]; then
		echo "ERROR: Fetching status from '$c' failed!" >&2
		continue
	fi

	# Validate output
	# - check for node name
	# - check for connection list
	# - check for IP list
	if [[ ! "$output" =~ ^hostname= ]]; then
		echo "ERROR: Result from '$c' missing hostname! Ignoring it." >&1
		continue
	fi

	# There should be at least one established connection (that's us!)
	if [[ ! "$output" =~ ESTABLISHED ]]; then
		echo "ERROR: Result from '$c' missing connection listing! Ignoring it." >&1
		continue
	fi
	
	# There should be at least one interface listed
	if [[ ! "$output" =~ inet\  ]]; then
		echo "ERROR: Result from '$c' missing interface listing! Ignoring it." >&1
		continue
	fi
	
	# Parse output and store into Redis
	now=$(date +%s)
	
	echo "Services:"
	unset listen_ports
	unset used_services
	while read proto recvq sendq localaddr remoteaddr state program rest; do
		localport=${localaddr##*:}
		program=${program##*/}
		program=${program:-unknown}
		echo "  -> listening on port $localport	(${program})"
		listen_ports[$localport]=${program}
		used_services[$localport]=0
	done < <(echo "$output" | grep "^tcp.*LISTEN" | egrep -v "$LISTEN_FILTER")

	echo "Connections:"
	while read proto recvq sendq localaddr remoteaddr state program rest; do
		localip=${localaddr%%:*}
		localport=${localaddr##*:}
		remoteip=${remoteaddr%%:*}
		remoteport=${remoteaddr##*:}
		program=${program##*/}
		program=${program:-unknown}

		if [[ "$localaddr" =~ ^127 && "$remoteaddr" =~ ^127 ]]; then
			echo "  -> local connection $localaddr -> $remoteaddr"
			conn_count=$(echo "$output" | grep "[[:space:]]$localip:[0-9][0-9]*[[:space:]]*$remoteaddr[[:space:]]" | wc -l)
			redis_push "dotm::connections::${c}::${localport}::${c}" process "$program" last_seen "$now" connections "$conn_count"
			used_services[$localport]=1
		elif [ "${listen_ports[${localaddr##*:}]}" == "" ]; then
			# FIXME: Consolidate outgoing connections to 'Internet'
			# according to list of configured known networks
			echo "  -> outgoing connection to $remoteaddr (by $program)"
			conn_count=$(echo "$output" | grep "[[:space:]]$localip:[0-9][0-9]*[[:space:]]*$remoteaddr[[:space:]]" | wc -l)
			redis_push "dotm::connections::${remoteip}::${remoteport}::${c}" process "$program" last_seen "$now" connections "$conn_count"
		else
			# FIXME: Consolidate incoming connections based on frequency
			# e.g. count per net and combine to network if too many appear
			echo "  -> incoming from $remoteaddr (to $localport $program)"
			conn_count=$(echo "$output" | grep "[[:space:]]$localaddr[[:space:]]*$remoteip:[0-9][0-9]*[[:space:]]" | wc -l)
			redis_push "dotm::connections::${c}::${localport}::${remoteip}" process "$program" last_seen "$now" connections "$conn_count"
			used_services[$localport]=1
		fi
	done < <(echo "$output" | grep ESTABL | egrep -v "$ESTABLISHED_FILTER")

	# Submit service list to indicate which ones are unused and which one are not
	for port in ${!used_services[*]};
	do
		program="${listen_ports[$port]}"
		program=${program:-unknown}
		if [[ ${used_services[$port]} -eq 0 ]]; then
			echo "  -> found unused service $port (${listen_ports[$port]})"
			redis_push "dotm::services::${c}::${port}" process "$program" last_seen "$now"
		else
			redis_push "dotm::services::${c}::${port}" process "$program" last_seen "$now" last_connection "$now"
		fi
	done

	echo "Interfaces:"
	echo "$output" | grep "inet " | grep -v "host lo"
done

echo "Done."
